<html xmlns="http://www.w3.org/1999/xhtml" prefix="schema: http://schema.org/ prism: http://prismstandard.org/namespaces/basic/2.0/"><head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  

  <link rel="stylesheet" href="css/bootstrap.min.css" />
  <link rel="stylesheet" href="css/rash.css" />

  <!-- JQuery -->
  <script src="js/jquery.min.js"></script>

  <!-- Bootstrap.js -->
  <script src="js/bootstrap.min.js"></script>

  <!-- Rash.js -->
  <script src="js/rash.js"></script>
  
  

  <!-- Local MathJax -->
  <script src="js/MathJax/MathJax.js"></script>

  <title>Algorithms</title>
  
  
  
  
  
<meta about="mailto:silvio.peroni@unibo.it" typeof="schema:Person" property="schema:name" name="dc.creator" content="Silvio Peroni" /><meta about="mailto:silvio.peroni@unibo.it" property="schema:email" content="silvio.peroni@unibo.it" /><link about="mailto:silvio.peroni@unibo.it" property="schema:affiliation" href="#affiliation_1" /><meta about="#affiliation_1" typeof="schema:Organization" property="schema:name" content="Digital And Semantic Publishing Laboratory, Department of Computer Science and Engineering, University of Bologna, Bologna, Italy" /><meta property="prism:keyword" content="algorithm" /><meta property="prism:keyword" content="Ada Lovelace" /><meta property="prism:keyword" content="pseudocode" /><meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0,minimum-scale=1.0,maximum-scale=1.0" /></head>

<body>
<section role="doc-abstract" id="doc-abstract">
<h1>Abstract</h1>
<p>These lecture notes introduce the notion of <em>algorithm</em> and <em>pseudocode</em>, so as to provide the initial tools for instructing a computer in executing a particular task. The historic hero introduced in these notes is Ada Lovelace, considered the first computer programmer. Her work in translating and commenting a scholarly paper describing Babbage's Analytical Engine has been one of the most important milestones of the Computer Science discipline.</p>
<p><strong>Copyright notice.</strong> This work is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>. You are free to share (i.e. copy and redistribute the material in any medium or format) and adapt (e.g. remix, transform, and build upon the material) for any purpose, even commercially, under the following terms: attribution, i.e. you must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. The licensor cannot revoke these freedoms as long as you follow the license terms.</p>
</section>
<section id="section1">
<h1>Historic hero: Ada Lovelace</h1>
<p><a href="https://en.wikipedia.org/wiki/Ada_Lovelace">Ada Lovelace</a> (shown in <a href="#img_1"> </a>) was a daughter of the poet <a href="https://en.wikipedia.org/wiki/Lord_Byron">Lord Byron</a>, and English mathematicians who became famous for her work on the Babbage's <a href="https://en.wikipedia.org/wiki/Analytical_Engine">Analytical Engine</a>. Despite her father's habits, her mother, <a href="https://en.wikipedia.org/wiki/Ada_Lovelace">Anne Isabella Milbanke</a>, strongly promoted Ada's interest in logic and mathematics, even after the death of her father. One of the goals of her mother was to prevent her to incur in the same insanity that characterised her father's life. However, the creativity that was intrinsically tied up on Byron family manifested in a totally unpredictable way.</p>
<figure id="img_1">
<p><img src="img/ada.jpg" alt="img/ada.jpg" /></p>
<figcaption>Portrait of Ada Lovelace. Source: <a href="https://en.wikipedia.org/wiki/File:Ada_Lovelace_portrait.jpg">https://en.wikipedia.org/wiki/File:Ada_Lovelace_portrait.jpg</a>.</figcaption>
</figure>
<p>In 1833, she attended a party organised by <a href="https://en.wikipedia.org/wiki/Charles_Babbage">Charles Babbage</a> for presenting its <a href="https://en.wikipedia.org/wiki/Difference_engine">Difference Engine</a>. She was so impressed by Babbage's invention that she started a corrispondence with him that spanned 27 years <a href="#biblioentry_2"> </a>. She was the English translator of the first article about the Analytical Engine, that was written in French by <a href="https://en.wikipedia.org/wiki/Luigi_Federico_Menabrea">Luigi Federico Menabrea</a>, and that she enriched with several annotations. Among these annotations, there was a description of how to use the Analytical Engine to calculate the <a href="https://en.wikipedia.org/wiki/Bernoulli_number">Bernoulli numbers</a> <a href="#biblioentry_3"> </a>. Technically speaking, this was the first computer program ever written (actually the first <em>algorithm</em> of the whole history) and it has been created by Ada without even having the real machine implemented – since the Analytical Engine was just a theoretical machine that was not physically built by Babbage.</p>
<p>However, her vision about the possible uses of the Analytical Engine went even further <a href="#biblioentry_2"> </a>:</p>
<blockquote>
<p>The operating mechanism can even be thrown into action independently of any object to operate upon (although of course no <em>result</em> could then be developed). Again, it might act upon other things besides <em>number</em>, were objects found whose mutual fundamental relations could be expressed by those of the abstract science of operations, and which should be also susceptible of adaptations to the action of the operating notation and mechanism of the engine. Supposing, for instance, that the fundamental relations of pitched sounds in the science of harmony and of musical composition were susceptible of such expression and adaptations, the engine might compose elaborate and scientific pieces of music of any degree of complexity or extent.</p>
</blockquote>
<p>That <q>science of operations</q> is a clear reference to a particular field that was clearly named and identified only after several years. In practice, Ada Lovelace was talking about Computer Science one hundred years before its formal introduction.For her work in the field, Ada Lovelace is recognised as the first computer programmer in history.</p>
</section>
<section id="section2">
<h1>Algorithms and programmers</h1>
<p>Before to introduce the main topic of this lecture note, it would be worth to focus on simple examples we usually face during our daily life. <a href="#img_2"> </a> illustrates two examples of step-by-step procedures we have to follow for preparing canapé crackers and for assembling a particular lamp respectively. While the actual goal of the two examples is extremely different, since the first one is a recipe while the other one is a set of instructions for assembling an utensil, the are described in terms of a shared abstract notion: instructions for <em>producing something</em> starting from some <em>initial material</em> we have.</p>
<figure id="img_2">
<p><img src="img/recipe-ikea.png" alt="img/recipe-ikea.png" /></p>
<figcaption>Two pictures depicting a recipe (left) and the instruction for assembling a lamp (right). Left picture by Phil! Gold, source: <a href="https://www.flickr.com/photos/phil_g/17282816/">https://www.flickr.com/photos/phil_g/17282816/</a>. Right picture by Richard Eriksson, source: <a href="https://www.flickr.com/photos/sillygwailo/3183183727/">https://www.flickr.com/photos/sillygwailo/3183183727/</a>.</figcaption>
</figure>
<p>The word <em><a href="https://en.wikipedia.org/wiki/Algorithm">algorithm</a></em> is a combination of the Latin word <em>algorismus</em> (that is the Latinization of the name <a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">Al-Khwarizmi</a>, who was a great mathematician from Persia in the 8<sup>th</sup> century) and the Greek word <em>arithmos</em>, meaning <em>number</em>. Broadly speaking, we can define an algorithm as an abstraction of a step-by-step procedure that takes something as <em>input</em> and produces some desired <em>output</em> <a href="#biblioentry_1"> </a>. Each algorithm is written in a specific language which is functional to communicate its instruction to a computer (either human or machine) so as to obtain something by processing some input material.</p>
<p>A <em><a href="https://en.wikipedia.org/wiki/Programmer">computer programmer</a></em> usually is a person who creates algorithms and specifies them in a <a href="https://en.wikipedia.org/wiki/Computer_program">computer program</a> according to a particular computer language – thus, the term <q>​computer</q> is here used for talking about an <em>electronic</em> computer. However, for what concerns the scope of this course, we use the term <q>​computer programmer</q> to refer to anyone that creates algorithms that can be interpreted by any computer, being it a human or a machine.</p>
</section>
<section id="section4">
<h1>Pseudocode</h1>
<p>There is no standard language for describing an algorithm in a way that it is immediately understandable by any computer. However, often Computer Scientists rely on <em>pseudocode</em> when they want to describe a particular algorith, Broadly speaking, a <a href="https://en.wikipedia.org/wiki/Pseudocode">pseudocode</a> is an informal language that could be interpreted easily by any computer, even if it is usually used for communicating the steps of a process to humans. While an algorithm described by means of a pseudocode is not runnable by an electronic computer, it constructs are closely tied to the ones that are typically defined, with a formal grammar, in programming languages.</p>
<p>In particular, any algorithm can be expressed in pseudocode and, in principle, that pseudocode can be translated into different programming languages quite easily. The real difference is that, usually, some passages in the pseudocode can be simplified by using even natural language text, while one has to specify clearly every passage if one uses a programming language.</p>
<p>In this lecture notes, as well as in the main part of the whole course, we use a particular pseudocode which is good for being understandable by both humans and machines at the same time. However, the goal of the algorithm we will develop during the first, theoretical, part of the course must be understood primarily by humans. Thus, a good way for checking if an algorithm one has developed (by means of the pseudocode) can be interpretable by a computer is to ask a colleague to execute it starting from a particular input – e.g. by writing down all the passages of the execution on a piece of paper. We discuss this task in detail in the following section.</p>
</section>
<section id="section5">
<h1>Our first algorithm</h1>
<p>The pseudocode we use for describing all the algorithms of this course is called <em>ThyMopani</em>, meaning <em>your tree</em>: <em>thy</em> is the archaic version of <em>your</em>, while <em>mopani</em> is a particular African tree with butterfly-shaped leaves. This language is enough expressive for allowing one to describe any kind of algorithm that can be implemented in any programming language. In this lecture notes, we see only the basic constructs, while we will address more specific and complex features in the following lectures.</p>
<p>The goal of today's lecture is to develop our first algorithm. It can be described informally by the following natural language text: taking in input three different <em>strings</em>, i.e. two words and a bibliographic entry of a published paper, return <i>2</i> if both the words are contained in the bibliographic entry, <em>1</em> if at least one of the words is contained in the bibliographic entry, and <em>0</em> otherwise.</p>
<section id="section7">
<h1>An incomplete version</h1>
<p>In ThyMopani, each algorithm is defined by using the keyword <code>def</code> (which stands for <em>define</em>) followed by the name of the algorithm and a comma-separated list of input parameters between round brackets, e.g. <code>def contains_word(first_word, second_word, bibliographic_entry)</code>​. This definition is then followed by <code>:</code> and all the instructions of the algorithm must be specified in the following lines, as an indented block (preferably using 4 spaces). This is illustrated in <a href="#listing_2"> </a>. It is worth mentioning that the name of the algorithm, as well as all the parameters, cannot contain space characters and must always start with a letter – e.g. <code>this_is_my_parameter</code> is correct, while <code>1_parameter</code> is not.</p>
<figure id="listing_2">
<pre><code>​def contains_word(first_word, second_word, bibliographic_entry):</code><br />    ...<br />    ...<br />    ...</pre>
<figcaption>The definition of an algorithm, with its input parameter, and some comments identifying where to put the various instruction of such algorithm – one per line, indented of 4 space characters.</figcaption>
</figure>
<p>In this first version of the algorithm, we would like to introduce only some basic constructs of ThyMopani. To this end, we provide only a partial solution in this subsection, which will be finalised in the following subsections. In particular, we want just to say that if the first input word is contained in the bibliographic entry, then the number <em>1</em> is returned, otherwise <em>0</em> is returned. This partial version of the algorithm is introduced in <a href="#listing_3"> </a>.</p>
<figure id="listing_3">
<pre><code>​def contains_word(first_word, second_word, bibliographic_entry):<br />    if first_word in bibliographic_entry: <br />        return 1<br />    else:<br />        return 0</code></pre>
<figcaption>An incomplete version of the algorithm, that is used to introduce some basic constructs of ThyMopani.</figcaption>
</figure>
<p>In this partial version, there are already specified some important constructs of ThyMopani. The first one is the <em>if-else</em> conditional block. This kind of block allows one to execute a particular instruction if a condition is true (the <code>if</code> statement), while an alternative set of instructions is executed instead if the condition specified is false (the <code>else</code> statement). The instructions to execute in one case or the other are specified in indented sub-blocks (again 4 additional spaces). As already introduced in <a href="#listing_3"> </a>, every time we have to introduce a new block of instructions, we need to use <code>​:</code> after the statement of interest, as shown in <a href="#listing_4"> </a>.</p>
<figure id="listing_4">
<pre><code>​if &lt;condition&gt;:<br />    ...<br />    ...<br />else:<br />    ...<br />    ...</code></pre>
<figcaption>The generic structure of an <em>if-else</em> conditional block.</figcaption>
</figure>
<p>The condition specified in the <code>if</code> statement shown in <a href="#listing_3"> </a> allows one to check if a certain string is contained in another one by means of the command <code>in</code>. In particular, <code>&lt;string1&gt; in &lt;string2&gt;</code> would be true if the value <em>&lt;string1&gt;</em> is contained in <em>&lt;string2&gt;</em>, where a <a href="https://en.wikipedia.org/wiki/String_(computer_science)"><em>string</em></a> is a particular type of value that records a sequence of characters, and it is usually defined by using the quotes. For instance, <code>"Peroni"</code>, <code>"Osborne"</code>, and <code>​"Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132"</code> are all strings. Note that <em>&lt;string1&gt;</em> and <em>&lt;string2&gt;</em> are just placeholders for strings: we can use directly strings, e.g. <code>"Peroni" in "Peroni beer"</code>, or variables referring to strings, as shown in <a href="#listing_3"> </a> – where a <em><a href="https://en.wikipedia.org/wiki/Variable_(computer_science)">variable</a></em> is a symbolic name that contains some information referred to as a value (e.g. <code>first_word</code>). For instance, any input value is, in fact, a particular kind of variable. As defined previously, all the input parameters of the algorithm are expected to refer to strings.</p>
<p>The last construct of the partial algorithm introduced in this sub-section is the return statements. It is defined by specifying the token <code>return</code> followed by the value (or the variable containing a value) that must be returned. The execution of a return statement finishes the whole execution of an algorithm – thus, all the instructions that follow that statement are not processed anymore. In the example in <a href="#listing_3"> </a>, two different numbers are returned, depending on which branch of the <em>if-else</em> block is actually executed. In particular, the algorithm returns <em>1</em> if the condition of the <code>if</code> statement is true, while it returns <em>0</em> otherwise. In ThyMopani, any number is defined by writing it down as it is – e.g. <code>​42</code> and <code>-42</code> for positive/negative integers, <code>1.625</code> and <code>-1.625</code> for positive/negative decimals. Note that strings and numbers are distinct kinds of objects – e.g. the string <code>"42"</code> and the number <code>42</code> (without the quotes) are not defining the same value at all.</p>
</section>
<section id="section8">
<h1>Complex boolean statements</h1>
<p>The original text of the algorithm, introduced in <a href="#section5"> </a>, explicitly mentions the simultaneous truth of two conditions for returning <em>2</em>: <q>​return 2 if both the words are contained in the bibliographic entry</q>. Of course, this can be handled by means of a hierarchy of <em>if-else </em>blocks, as shown in <a href="#listing_5"> </a>.</p>
<figure id="listing_5">
<pre><code>​if first_word in bibliographic_entry:<br />    if second_word in bibliographic_entry:<br />        return 2<br />    else:<br />        return 1<br />else:<br />    if second_word in bibliographic_entry:<br />        if first_word in bibliographic_entry:<br />            return 2<br />        else:<br />            return 1<br />    else:<br />        return 0</code></pre>
<figcaption>A hierarchy of <em>if-else</em> blocks for describing the three possible return values of the algorithm.</figcaption>
</figure>
<p>However, the readability of the previous example is rather difficult, since it repeats several times the same conditions, even if they have been specified in a different order. Thus, ThyMopani makes available some operations for assessing compositions of multiple <a href="https://en.wikipedia.org/wiki/Boolean_data_type"><em>boolean values</em></a>, and for deriving boolean values from number and string comparisons. A boolean type (or, simply, <em>boolean</em>, named after <a href="https://en.wikipedia.org/wiki/George_Boole">George Boole</a>, who was a great logician of the 19<sup>th</sup> century) can be assigned to one out of two distinct and disjoint values, <em>True</em> and <em>False</em>. For instance, the condition <code>first_word in bibliographic_entry</code> returns a particular boolean: <em>True</em> if the word is indeed contained in the bibliographic entry, <em>False</em> otherwise. In algorithms (and in any programming language), boolean values are used for organising the execution flow of conditional blocks.</p>
<p>Sometimes it is useful to combine somehow two distinct boolean values in order to simplify the organisation of the conditional blocks. This can be done by using specific operators that apply to one (<code>&lt;operator&gt; &lt;B1&gt;</code>) or two boolean values (<code>&lt;B1&gt; &lt;operator&gt; &lt;B2&gt;</code>), and return a new boolean value. These operators are called <em>logical not</em> (<code>​not</code> in ThyMopani, which applies to one boolean value only), <em>logical and </em>(<code>​and</code>, between two boolean values), and <em>logical or</em> (<code>​or</code>, between two boolean values). They are <em>logical</em> operators since all of them derive from the logic Boole proposed in his works on <a href="https://en.wikipedia.org/wiki/Boolean_algebra">Boolean algebra</a>. Their use is summarised in <a href="#table_1"> </a>, where the <em><a href="https://en.wikipedia.org/wiki/Truth_table">truth table</a></em> of the application of such operators is shown. In particular, given two input boolean values, <em>B1</em> and <em>B2</em>, the table shows the result of all their possible combinations according to the specific operator. Thus, for instance, in the example in <a href="#listing_5"> </a>, we could return <em>2</em> if both the strings are contained in the bibliographic reference, expressing this constraint in one condition only, i.e. <code>first_word in bibliographic_entry and second_word in bibliographic_entry</code>.</p>
<figure id="table_1">
<table>
<tbody>
<tr>
<th>B1</th>
<th>B2</th>
<th>not B1</th>
<th>B1 and B2</th>
<th>B1 or B2</th>
</tr>
<tr>
<td>
<p>True</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>True</p>
</td>
</tr>
<tr>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
</tr>
<tr>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
</tr>
<tr>
<td>
<p>False</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>False</p>
</td>
</tr>
</tbody>
</table>
<figcaption>The truth table of all the boolean operations.</figcaption>
</figure>
<p>Round brackets can be used for grouping boolean operations, e.g. <code>(True and False) or False</code> applies the <code>and</code> operation first, and the result is used as the first value of the <code>or</code> operation – given <em>False</em> as result. In case no brackets are used, the application order is the following: first, all the <code>not</code> operation are applied, then all the <code>or</code> operations, and finally the remaining <code>and</code> operations – for instance, <code>​True and not False or False</code> returns <em>True</em> since it is interpreted as <code>True and ((not False) or False)</code>.</p>
<p>In addition to the aforementioned boolean operations, it is also possible to use string comparisons for obtaining boolean values. <a href="#table_3"> </a> shows all the comparisons that one can apply on two strings, i.e. <code>&lt;S1&gt; &lt;operator&gt; &lt;S2&gt;</code>. In this case, the operators are those typically used numerical comparison, i.e.:</p>
<ul>
<li>
<p><code>​&lt;</code>, less than;</p>
</li>
<li>
<p><code>​&lt;=</code>, less than or equal to;</p>
</li>
<li>
<p><code>​&gt;</code>, greater than;</p>
</li>
<li>
<p><code>​&gt;=</code> greater than or equal to;</p>
</li>
<li>
<p><code>​==</code>, equal to;</p>
</li>
<li>
<p><code>​!=</code>, different from;</p>
</li>
<li>
<p>​<code>​in</code>, included in;</p>
</li>
<li>
<p><code>​not in</code>, not included in.</p>
</li>
</ul>
<figure id="table_3">
<table>
<tbody>
<tr>
<th>S1</th>
<th>S2</th>
<th>S1 &lt; S2</th>
<th>S1 &lt;= S2</th>
<th>S1 &gt; S2</th>
<th>S1 &gt;= S2</th>
<th>S1 == S2</th>
<th>S1 != S2</th>
<th>S1 in S2</th>
<th>S1 not in S2</th>
</tr>
<tr>
<td>
<p>"Alice"</p>
</td>
<td>
<p>"Bob"</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
</tr>
<tr>
<td>
<p>"Alice"</p>
</td>
<td>
<p>"Alice"</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
</tr>
</tbody>
</table>
<figcaption>The truth table of all string comparisons.</figcaption>
</figure>
<p>In the case of strings, a string <em>S1</em> is <em>less than</em> another string <em>S2</em> if the former one precedes the latter one according to a pure alphabetic order. Of course, the alphabetic order is used also for assessing when a string is <em>greater than</em> another one.</p>
<p>Note that similar operators (excluding <code>in</code>) can be used also for comparing numbers, as shown in <a href="#table_2"> </a>. In this cases, the common mathematical numeric comparisons hold. </p>
<figure id="table_2">
<table>
<tbody>
<tr>
<th>N1</th>
<th>N2</th>
<th>N1 &lt; N2</th>
<th>N1 &lt;= N2</th>
<th>N1 &gt; N2</th>
<th>N1 &gt;= N2</th>
<th>N1 == N2</th>
<th>N1 != N2</th>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>False</p>
</td>
<td>True</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>False</p>
</td>
<td>
<p>True</p>
</td>
<td>
<p>True</p>
</td>
<td>False</td>
</tr>
</tbody>
</table>
<figcaption>The truth table of all the arithmetic comparisons.</figcaption>
</figure>
<p>Thus, we can reuse these boolean operations in order to rewrite the <em>if-else</em> blocks shown in <a href="#listing_5"> </a> in a more readable way. The result is shown in <a href="#listing_6"> </a>.</p>
<figure id="listing_6">
<pre><code>​if first_word in bibligraphic_entry and second_word in bibliographic_entry:<br />    return 2<br />else:<br />    if first_word in bibliographic_entry or second_word in bibliographic_entry:<br />        return 1<br />    else:<br />        return 0</code></pre>
<figcaption>A hierarchy of <em>if-else</em> blocks shown in <a href="#listing_5"> </a> rewritten according to the boolean operations presented in this section.</figcaption>
</figure>
</section>
<section id="section9">
<h1>Conditional statements with multiple branches</h1>
<p>While in the previous subsections we have improved the readability of the <em>if-else</em> blocks, ThyMopani allows us to do even better. First of all, in the two <code>if</code> statements in <a href="#listing_6"> </a>, we ask to evaluate the same sub-conditions (i.e. <code>first_word in bibliographic_entry</code> and <code>second_word in bibliographic_entry</code>) twice. This can be easily avoided by defining new variables. A variable are defined by specifying its name (without spaces), followed by an <code>=</code> and the value to associate to it, i.e. <code>&lt;variable_name&gt; = &lt;variable_value&gt;</code>. The value can be specified directly (e.g. a number) or indirectly by using other existing variables, or even complex operations.</p>
<p>In our example, we could create two variables, called <code>contains_first_word</code> and <code>contained_second_word</code>, assigned to the boolean returned by the aforementioned string comparisons, i.e. <code>first_word in bibliographic_entry</code> and <code>second_word in bibliographic_entry</code> respectively. In that way, we can reuse such variables in the two <code>if</code> statements, as shown in <a href="#listing_7"> </a>.</p>
<figure id="listing_7">
<pre><code>​if contains_first_word and contains_second_word:<br />    return 2<br />else:<br />    if contains_first_word or contains_second_word:<br />        return 1<br />    else:<br />        return 0</code></pre>
<figcaption>The <em>if-else</em> blocks introduced in <a href="#listing_6"> </a> where the conditions in the <code>if</code> statements are specified by means of two variables.</figcaption>
</figure>
<p>In addition to that, we can improve even further the readability of the code by collapsing occurrences of <code>else</code> statements when these contain an <code>if</code> statement as their first instruction. In this case, both the <em>else-if</em> pair can be safely replaced by an <code>elif</code> (i.e. <em>else if</em>) statement, which specifies the same condition used in the <code>if</code> statement. Thus, the code in <a href="#listing_7"> </a> can be rewritten as shown in <a href="#listing_8"> </a>.</p>
<figure id="listing_8">
<pre><code>​if contains_first_word and contains_second_word:<br />    return 2<br />elif contains_first_word or contains_second_word:<br />    return 1<br />else:<br />    return 0</code></pre>
<figcaption>The <em>if-else</em> blocks introduced in <a href="#listing_7"> </a> collapsed my means of an <code>elif</code> statement.</figcaption>
</figure>
</section>
<section id="section10">
<h1>Final algorithm</h1>
<p>In this lecture we have seen some initial constructs that ThyMopani makes available for developing an algorithm, in particular: algorithm definition with input parameters, variables, conditional statements (i.e. <code>if</code>, <code>elif</code>, and <code>else</code>), string, numeric, and boolean values, as well as boolean operations and string and numeric comparisons. All these constructs enabled us to define our algorithm, which is finally introduced in <a href="#listing_1"> </a>.</p>
<figure id="listing_1">
<pre><code>def contains_word(first_word, second_word, bibliographic_entry):<br />    contains_first_word = first_word in bibliographic_entry <br />    contains_second_word = second_word in bibliographic_entry <br />    <br />    if contains_first_word and contains_second_word: <br />        return 2<br />    elif contains_first_word or contains_second_word: <br />        return 1<br />    else: <br />        return 0<br /></code></pre>
<figcaption>The final algorithm developed.</figcaption>
</figure>
</section>
</section>
<section id="section6">
<h1>Exercises</h1>
<ol>
<li>
<p>What is the boolean value of <code>not (not True or False and True) or False</code>?</p>
</li>
<li>
<p>What is the boolean value of <code>"spam" not in "spa span sparql" and not ("egg" &gt; "span")</code>?</p>
</li>
<li>
<p>What is the result of the execution of the algorithm in <a href="#listing_1"> </a> using <code>"Peroni"</code>, <code>"HTML"</code>, and <code>"Peroni, S., Osborne, F., Di Iorio, A., Nuzzolese, A. G., Poggi, F., Vitali, F., Motta, E. (2017). Research Articles in Simplified HTML: a Web-first format for HTML-based scholarly articles. PeerJ Computer Science 3: e132. e2513. DOI: https://doi.org/10.7717/peerj-cs.132"</code> as input values?</p>
</li>
</ol>
</section>
<section id="doc-bibliography" role="doc-bibliography">
<h1>References</h1>
<ul>
<li role="doc-biblioentry" id="biblioentry_3">
<p>Menabrea, L. F. (1842). Sketch of the Analytical Engine Invented by Charles Babbage – With notes upon the Memoir by the Translator: Ada Augusta, Countess of Lovelace. Scientific Memoirs, 3. <a href="http://www.fourmilab.ch/babbage/sketch.html">http://www.fourmilab.ch/babbage/sketch.html</a></p>
</li>
<li role="doc-biblioentry" id="biblioentry_2">
<p>Morais, B. (2013). Ada Lovelace, the First Tech Visionary. The New Yorker. <a href="https://www.newyorker.com/tech/elements/ada-lovelace-the-first-tech-visionary">https://www.newyorker.com/tech/elements/ada-lovelace-the-first-tech-visionary</a> (last visited 2 November 2017)</p>
</li>
<li role="doc-biblioentry" id="biblioentry_1">
<p>Wing, J. M. (2008). Computational thinking and thinking about computing. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 366 (1881): 3717. <a href="https://doi.org/10.1098/rsta.2008.0118">https://doi.org/10.1098/rsta.2008.0118</a></p>
</li>
</ul>
</section></body></html>